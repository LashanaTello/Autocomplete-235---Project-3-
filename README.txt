Lashana Tello
CSCI 235, Section 3
Professor Aarsh Vora
Project 3

	This program "autocompletes" a user-given word fragment and the number of word suggestions output to the user depends on the number of suggestions the user requested. For example, the program will ask for a word fragment, such as "str". It will then ask how many suggestions the user wants and the user may enter "7", for instance. The program will then output seven words or less (if it can not find seven words close to the word fragment).
	Open the zip file and move the folder "TELLO_LASHANA_PROJECT3" to your home directory. Right click on the folder, and you should see the option, "Open in Terminal." Type "make all" and then type "./Autocomplete". The program will then ask the user for the text file containing a list of all words that will be used as a dictionary. Type "words.txt", which is the name of the included file containing over 235,000 words.
	For Project 3, I completed all parts of the assignment. The Trie class and the Dictionary class donâ€™t appear to have any issues. My Dictionary class doesn't have any insert and remove functions like the Trie class. I didn't think the user should be able to add and remove words from the Dictionary.
	I don't think there are any bugs in either class. As long as the file that each class ifstreams from is in the proper format (one word on each line), everything should be fine.
	For this project, we create a Trie that stores words by having a node represent a single character and all the possible letters after that character. A lot of words have the same prefix so a Trie helps minimize the space required to store a dictionary. The Trie class abstracts away the TrieNode pointer to the root, which contains the first letter of all the words in the Trie, and an int that stores the number of words in the Trie. A TrieNode is a struct that contains a map and a boolean value. The map uses a character as the key and TrieNode pointers as the value. The map contains all the possible next letters and pointers to the node of each letter. The boolean value tells you whether or not you've reached the end of a word. The Dictionary class is just a wrapper class for the Trie, but the user can't add or remove words from the Trie using the Dictionary class. The Dictionary class just calls the Trie's methods. 
	The insert method and the remove helper method, and the autocomplete method of the Trie class have nontrivial algorithms. For the insert method, we use a TrieNode pointer named traverse to go through the Trie. First check if a character in the word exists in the Trie by searching the map of the node traverse points to. If it doesn't, create a new node and insert it in the current node's map at the position whose key is equal to the character we're inserting. From that point, continue creating new nodes to insert the rest of the characters of the word. But for the last character, insert a nullptr in the position corresponding to the last character because a nullptr means we reached the end of a word. If a character does exist, make traverse point to the node associated with that character to continue traversing the Trie. If we reach a nullptr before we reach the end of the word we're inserting, create a new node and insert it at the current letter's position in the map to continue inserting the word. There's also a boolean value that tells you whether or not the word we're inserting already exists in the Trie. After inserting the word (or not), if the boolean is true, add 1 to the word count and return true. If the boolean is false, check if traverse is a nullptr or if traverse's end_of_word is true. If either of these is true, return false; you can't insert a word that already exists. If traverse is not a nullptr and its end_of_word is false, change the end_of_word to true and return true. In this case, the word technically existed in the Trie but it wasn't considered a word. 
	The remove helper method is recursive and calls itself until it reaches the length of the word. Once it does, return 2, 1 or 0. Return 0 if the word does not exist in Trie. If the node associated with the last letter of the word is not a nullptr and its end_of_word is true, change it to false, subtract 1 from the word_count_ and return 1. Nothing else needs to get done. If the node associated with the last letter of the word is null, subtract 1 from the word_count_ and return 2. This will tell the function to erase the next character from the current node's map. Next, if the map is empty and the node's end_of_word is false, delete this node and return 2 again. Keep doing this until the word is removed or you encounter a node that has a true end_of_word value. If the map is empty and the node's end_of_word is true, delete this node and return 1 to tell the function it no longer needs to delete anything. This is to make sure we don't delete another word accidentally. 
	The autocomplete method uses a level order traversal to find words that are close to the given prefix. First, call method find_prefix to get the node associated with the last letter of the prefix. Create a vector to store all the possible strings, a pair that stores a string and a TrieNode pointer, and a queue that stores that pair. Set pair's string equal to the prefix and make pair's pointer point to the node associated with the last letter of the prefix. Push pair into queue. Inside a while loop, get the front of the queue and store it in a pair variable. If pair's pointer member is null or its end_of_word is true, push pair's string into the vector. As you traverse through the children of the node that pair's pointer points to, create a string by adding the key (a letter) to the prefix and then get the pointer associated with that key and store them in a pair. Then push the pair into the queue. Before moving on to the next key, remove the last letter from the prefix to return it to its original state. After you've gotten through all the children, dequeue. Continue in this while loop until the vector size is equal to the given number of suggestions and return the vector.
